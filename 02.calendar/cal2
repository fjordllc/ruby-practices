#!/usr/bin/env ruby
require "date"
today = Date.today
require "optparse"
opt = OptionParser.new
# 年と月の入力が無い場合初期値として今日の年月を代入
@selected_month = today.mon
@selected_year = today.year
opt.on('-m', '--add ITEM') { |v| @selected_month = v.to_i}
opt.on('-y', '--add ITEM') { |v| @selected_year = v.to_i}
opt.parse!(ARGV)
# 初日の曜日を代入
@weekday_of_firstday = today.wday
selected_firstday = Date.new(@selected_year, @selected_month, 1)
@weekday_of_firstday = selected_firstday.wday
puts "      #{@selected_month}月 #{@selected_year}"
puts "日 月 火 水 木 金 土"
month_31day = ["1", "3", "5", "7", "8", "10", "12"]
month_30day = ["4", "6", "9", "11"]
# 引数の日にちのカレンダーを表示させるメソッドを定義
def calendar(day)
  range_a_digit = (1..9)
  range = (10..day)
  array = []
  # 一桁の日付を半角スペースと一緒に空の配列に追加
  range_a_digit.each {|a| array.push " #{a}"}
  # 二桁の日付を配列に追加
  range.each {|a| array.push a}
  # 一日の曜日が合うように配列の先頭にスペースを追加
  @weekday_of_firstday.times {array.unshift "  "} 
  # できた配列の要素を7個ごとに配列にし、その配列を要素に持つ配列を作成
  week_array = array.each_slice(7).to_a {|a| p a}   
  # 配列をそれぞれ表示、改行する 
  week_array.each do |a|
    print a.join(" ")
    puts ""
  end
end
if @selected_month == 2
  # 閏年の2月
  if @selected_year % 4 == 0    
    calendar(29)
    # 閏年以外の2月 
  else
    calendar(28)
  end
  # 31日の月
  elsif month_31day.include? "#{@selected_month}"
    calendar(31)
  # 30日の月
  elsif month_30day.include? "#{@selected_month}"
    calendar(30)
end